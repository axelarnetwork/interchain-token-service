#!/usr/bin/env zx
import { convertCase } from '@axelarjs/utils/case-conversion';
import { capitalize } from '@axelarjs/utils/string';

import fs from 'fs/promises';
import path from 'path';
import prettier from 'prettier';
import { $ } from 'zx';

$.verbose = false;

const kebabToPascalCase = convertCase('kebab-case', 'PascalCase');

const kebabToConstantCase = convertCase('kebab-case', 'CONSTANT_CASE');

const CONTRACT_FOLDERS = ['interchain-token-service', 'interchain-token', 'token-manager', 'token-implementations'];

type ABIInputItem = {
    name: string;
    type: string;
};

type ABIItem = {
    name: string;
    type: string;
    inputs: {
        name: string;
        type: string;
    }[];
};

const getInputType = (input: ABIInputItem) => {
    switch (input.type) {
        // string types
        case 'address':
        case 'bytes32':
        case 'bytes':
            return '`0x${string}`';
        case 'string':
            return 'string';
        // number types
        case 'uint256':
            return 'bigint';
        case 'uint8':
            return 'number';
        // boolean
        case 'bool':
            return 'boolean';
        // default
        default:
            return 'any';
    }
};

async function main(folders: string[], subDir?: string) {
    folders.forEach(async (folder) => {
        const pascalName = kebabToPascalCase(folder).split('.')[0];
        const constantName = kebabToConstantCase(folder).split('.')[0];

        const remainingPath = 'dist/' + (subDir ? `${subDir}/` : '') + folder;
        const dirName = process.cwd() + '/' + remainingPath;

        const dirs = (await fs.readdir(dirName, { withFileTypes: true }))
            .filter((dirent: any) => dirent.isDirectory())
            .map((dirent: any) => dirent.name);

        if (dirs.length > 0) {
            await main(dirs, subDir ? subDir + '/' + folder : folder);
        } else {
            const { stdout: abiFileJson } = await $`cat ${remainingPath}/${pascalName}.json`;
            const folderName = folder.split('.')[0];

            const GENERATED_DISCLAIMER = `
                /* eslint-disable @typescript-eslint/no-explicit-any */
                /**
                 * This file was generated by scripts/codegen.ts
                 * 
                 * Original abi file: 
                 * - ${remainingPath}/${pascalName}.json
                 * 
                 * DO NOT EDIT MANUALLY
                 */
                `;

            const { abi, contractName } = JSON.parse(abiFileJson) as {
                abi: ABIItem[];
                contractName: string;
            };

            const abiJsonFile = `${JSON.stringify({ contractName, abi }, null, 2)}`;

            const basePath = path.join('typescript', 'contracts', folder);

            // only generate args file if there are functions with inputs
            const abiFns = abi.filter((x) => x.type === 'function' && x.inputs.length && x.inputs.every((input) => input.name));

            const argsFile = `
                import { encodeFunctionData } from "viem";
    
                import ABI_FILE from "./${folderName}.abi";
    
                ${abiFns
                    .map(({ name, inputs }) => {
                        const argNames = inputs.map(({ name = '' }) => name).join(', ');

                        const argsType = inputs.map((input) => `${input.name}: ${getInputType(input)}`).join('; ');

                        const fnName = capitalize(name);
                        const typeName = `${pascalName}${fnName}Args`;

                        return `
                        export type ${typeName} = {${argsType}}
            
                        /**
                         * Factory function for ${pascalName}.${name} function args
                         */
                        export const encode${pascalName}${fnName}Args = ({${argNames}}: ${typeName}) => [${argNames}] as const;
            
                        /**
                         * Encoder function for ${pascalName}.${name} function data
                         */
                        export const encode${pascalName}${fnName}Data = ({${argNames}}: ${typeName}) => encodeFunctionData({
                        functionName: "${name}",
                        abi: ABI_FILE.abi,
                        args:[${argNames}]
                        });
                    `;
                    })
                    .join('\n\n')}
                `;

            const abiFile = `
                export default ${abiJsonFile} as const;
                `;

            const indexFile = `
                import { Chain } from "viem";
    
                import { PublicContractClient } from "../../client/PublicContractClient";
                import ABI_FILE from "./${folderName}.abi";
                
                export * from "./${folderName}.args";
    
                export const ${constantName}_ABI = ABI_FILE.abi;
    
                export class ${contractName}Client extends PublicContractClient<
                    typeof ABI_FILE.abi
                > {
                    static ABI = ABI_FILE.abi;
                    static contractName = ABI_FILE.contractName;
    
                    constructor(options: { chain: Chain; address: \`0x\${string}\` }) {
                    super({
                        abi: ${constantName}_ABI,
                        address: options.address,
                        chain: options.chain,
                    });
                    }
                }
                `;

            await $`mkdir -p ${basePath} && touch ${basePath}/index.ts`;

            const files = [
                {
                    name: 'index.ts',
                    content: indexFile,
                    parser: 'babel-ts',
                },
                {
                    name: `${folderName}.abi.ts`,
                    content: abiFile,
                    parser: 'babel-ts',
                },
                {
                    name: `${folderName}.args.ts`,
                    content: argsFile,
                    parser: 'babel-ts',
                },
            ];

            await Promise.all(
                files.map(async ({ name, content, parser }) =>
                    fs.writeFile(
                        path.join(basePath, name),
                        prettier.format(parser === 'json' ? content : `${GENERATED_DISCLAIMER}\n\n${content}`, { parser })
                    )
                )
            );

            console.info(`Synced ${folder} contract ABI.`, {
                functions: abiFns.length,
            });
            console.info(`Synced ${CONTRACT_FOLDERS.length} contract ABIs.\n`, `Generated code can be found in the typescript directory`);
        }
    });
}

main(CONTRACT_FOLDERS).catch((err) => {
    console.error(err);
    process.exit(1);
});
